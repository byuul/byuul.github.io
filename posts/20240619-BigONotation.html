<!DOCTYPE html><html><body><div id="__next"><div class="layout_container__YX1XY"><article><img src="https://github.com/byuul/leetcode/assets/149779257/28611718-85cb-4688-af12-d973024eeac7"/><h1 class="utils_headingXl__zlq1q">BigO</h1><div class="utils_lightText__B_gv3"><time dateTime="2024-06-19">June 19, 2024</time></div><div><h3>Big O 표기법의 필요성</h3>
<ul>
<li>숫자로 코드의 성능을 표기 === 빅오 형식으로 표기</li>
<li>비효율적인 코드의 문제를 찾기 쉽다.</li>
<li>코드를 더 잘 이해하고, 더 좋은 코드를 쓰기 위해 필요</li>
</ul>
<p>E.g Suppose we want to write a function that calculates the sum of all numbers from 1 up to (and including) some number n</p>
<p>3 = 1 + 2 + 3</p>
<pre><code>// Solution 1
function addUpTo(n) {
    let total = 0;
    for (let i = 1; i &#x3C;= n; i++) {
        total = total + i;
    }

    return total;
}
</code></pre>
<pre><code>// Solution 2
function addUpTo(n) {
    return (n * (n + 1)) / 2;
}
</code></pre>
<p>두 코드의 속도 차를 구하기</p>
<pre><code>let t1 = performance.now();
console.log(addUpTo(100000));
let t2 = performance.now(2);

console.log(`time elapsed : ${(t2 - t1) / 1000} seconds.`);
</code></pre>
<p>이런 식으로 불확실하게 시간 차를 구하기엔 한계가 있다.
기기 사양에 따라 다를 수도 있고, 무엇을 실행하고 있냐에 따라 다를 수 있다.</p>
<p>이를 위해 <code>Big O</code> 표기법을 사용한다.</p>
<p>BigO = 입력의 크기와 실행시간의 관계, N의 값이 커질 수록 실행 시간이 늘어난다
입력값 n이 커질수록 알고리즘이 얼마나 효율적인지 표현하는 방식이란것을 기억한다.</p>
<p>O(n) => n이 커질수록 비례하게 실행 시간이 늘어남
O(n2) => 실행 시간이 대략 n 제곱으로 늘어남</p>
<ul>
<li></li>
</ul>
<h3>Big O Shorthands</h3>
<ol>
<li>산수는 상수 (덧셈, 뺄셈, 곱셈, 나눗셈 포함, n의 값도 상관 없다.)</li>
<li>변수 배정도 상수. (x=1000, x=20000을 처리하든 100만을 처리하는 것은 비슷한 시간이 걸린다)</li>
<li>인덱스를 사용해서 배열 엘리멘트에 접근하면 그것도 실행 시간은 상수다.</li>
<li>루프가 있으면 복잡도가 루프의 길이 곱하기 루프 안에 있는 연산들이 된다. 그렇기 떄문에 리스트에 있는 데이터를 프로 처리할 떄 0에서 n까지 간다면, n이 커질 수록 루프 반복된느 횟수가 늘어간다. = n제곱 실행시간</li>
</ol>
<ul>
<li></li>
</ul>
<p>Recap</p>
<ol>
<li>알고리즘의 성능을 분석하기 위해서는 biG o 표기법을 사용한다.</li>
<li>빅오를 통해 시간 복잡도와 공간 복잡도에 대한 이해를 높일 수 있다.</li>
<li>빅오로 측정되는 알고리즘의 시간과 공간 복잡도는 하드웨어에 영향을 받지 않는다.</li>
</ol>
</div></article></div><footer></footer></div><script id="__NEXT_DATA__" type="application/json" crossorigin="">{"props":{"pageProps":{"postData":{"id":"20240619-BigONotation","contentHtml":"\u003ch3\u003eBig O 표기법의 필요성\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e숫자로 코드의 성능을 표기 === 빅오 형식으로 표기\u003c/li\u003e\n\u003cli\u003e비효율적인 코드의 문제를 찾기 쉽다.\u003c/li\u003e\n\u003cli\u003e코드를 더 잘 이해하고, 더 좋은 코드를 쓰기 위해 필요\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eE.g Suppose we want to write a function that calculates the sum of all numbers from 1 up to (and including) some number n\u003c/p\u003e\n\u003cp\u003e3 = 1 + 2 + 3\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// Solution 1\nfunction addUpTo(n) {\n    let total = 0;\n    for (let i = 1; i \u0026#x3C;= n; i++) {\n        total = total + i;\n    }\n\n    return total;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003e// Solution 2\nfunction addUpTo(n) {\n    return (n * (n + 1)) / 2;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e두 코드의 속도 차를 구하기\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003elet t1 = performance.now();\nconsole.log(addUpTo(100000));\nlet t2 = performance.now(2);\n\nconsole.log(`time elapsed : ${(t2 - t1) / 1000} seconds.`);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이런 식으로 불확실하게 시간 차를 구하기엔 한계가 있다.\n기기 사양에 따라 다를 수도 있고, 무엇을 실행하고 있냐에 따라 다를 수 있다.\u003c/p\u003e\n\u003cp\u003e이를 위해 \u003ccode\u003eBig O\u003c/code\u003e 표기법을 사용한다.\u003c/p\u003e\n\u003cp\u003eBigO = 입력의 크기와 실행시간의 관계, N의 값이 커질 수록 실행 시간이 늘어난다\n입력값 n이 커질수록 알고리즘이 얼마나 효율적인지 표현하는 방식이란것을 기억한다.\u003c/p\u003e\n\u003cp\u003eO(n) =\u003e n이 커질수록 비례하게 실행 시간이 늘어남\nO(n2) =\u003e 실행 시간이 대략 n 제곱으로 늘어남\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eBig O Shorthands\u003c/h3\u003e\n\u003col\u003e\n\u003cli\u003e산수는 상수 (덧셈, 뺄셈, 곱셈, 나눗셈 포함, n의 값도 상관 없다.)\u003c/li\u003e\n\u003cli\u003e변수 배정도 상수. (x=1000, x=20000을 처리하든 100만을 처리하는 것은 비슷한 시간이 걸린다)\u003c/li\u003e\n\u003cli\u003e인덱스를 사용해서 배열 엘리멘트에 접근하면 그것도 실행 시간은 상수다.\u003c/li\u003e\n\u003cli\u003e루프가 있으면 복잡도가 루프의 길이 곱하기 루프 안에 있는 연산들이 된다. 그렇기 떄문에 리스트에 있는 데이터를 프로 처리할 떄 0에서 n까지 간다면, n이 커질 수록 루프 반복된느 횟수가 늘어간다. = n제곱 실행시간\u003c/li\u003e\n\u003c/ol\u003e\n\u003cul\u003e\n\u003cli\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eRecap\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e알고리즘의 성능을 분석하기 위해서는 biG o 표기법을 사용한다.\u003c/li\u003e\n\u003cli\u003e빅오를 통해 시간 복잡도와 공간 복잡도에 대한 이해를 높일 수 있다.\u003c/li\u003e\n\u003cli\u003e빅오로 측정되는 알고리즘의 시간과 공간 복잡도는 하드웨어에 영향을 받지 않는다.\u003c/li\u003e\n\u003c/ol\u003e\n","title":"BigO","date":"2024-06-19","thumbnail":"https://github.com/byuul/leetcode/assets/149779257/28611718-85cb-4688-af12-d973024eeac7","description":"Big O Notation"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"20240619-BigONotation"},"buildId":"JzSdbTkoh4-wHiQqmw8C4","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>